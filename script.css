document.addEventListener('DOMContentLoaded', function() {
    // DOM elements
    const fileInput = document.getElementById('vocab-file');
    const learningArea = document.getElementById('learning-area');
    const cardContainer = document.getElementById('card-container');
    const questionEl = document.getElementById('question');
    const answerEl = document.getElementById('answer');
    const showAnswerBtn = document.getElementById('show-answer');
    const ratingButtons = document.getElementById('rating-buttons');
    const progressIndicator = document.getElementById('progress-indicator');
    const statsContainer = document.getElementById('stats-container');
    
    // App state
    let vocabulary = [];
    let currentCardIndex = 0;
    let reviewQueue = [];
    let spacedRepetitionData = {};
    
    // Create progress bar
    const progressBar = document.createElement('div');
    progressBar.className = 'progress';
    progressIndicator.appendChild(progressBar);
    
    // File input handler
    fileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            parseVocabularyFile(e.target.result);
            initializeReview();
        };
        reader.readAsText(file);
    });
    
    // Parse vocabulary file (term:description format)
    function parseVocabularyFile(content) {
        vocabulary = [];
        const lines = content.split('\n');
        
        lines.forEach(line => {
            if (line.trim() === '') return;
            
            const parts = line.split(':');
            if (parts.length >= 2) {
                const term = parts[0].trim();
                const description = parts.slice(1).join(':').trim();
                vocabulary.push({ term, description });
            }
        });
        
        // Initialize spaced repetition data
        vocabulary.forEach((item, index) => {
            spacedRepetitionData[index] = {
                interval: 1,
                nextReview: Date.now(),
                easeFactor: 2.5,
                repetitions: 0
            };
        });
    }
    
    // Initialize the review session
    function initializeReview() {
        if (vocabulary.length === 0) return;
        
        // Build initial review queue
        reviewQueue = [];
        vocabulary.forEach((_, index) => {
            if (isReadyForReview(index)) {
                reviewQueue.push(index);
            }
        });
        
        // Sort by due date
        reviewQueue.sort((a, b) => 
            spacedRepetitionData[a].nextReview - spacedRepetitionData[b].nextReview
        );
        
        cardContainer.classList.remove('hidden');
        currentCardIndex = 0;
        showNextCard();
        updateStats();
    }
    
    // Check if a card is ready for review
    function isReadyForReview(index) {
        return spacedRepetitionData[index].nextReview <= Date.now();
    }
    
    // Show the next card
    function showNextCard() {
        if (currentCardIndex >= reviewQueue.length) {
            // End of session
            questionEl.textContent = "Review complete!";
            answerEl.classList.add('hidden');
            showAnswerBtn.classList.add('hidden');
            ratingButtons.classList.add('hidden');
            
            // Check if there are any cards due in the next 24 hours
            const nextReviewTime = getNextReviewTime();
            if (nextReviewTime) {
                const timeUntilNext = Math.ceil((nextReviewTime - Date.now()) / (1000 * 60));
                questionEl.textContent += ` Next review in ${timeUntilNext} minutes.`;
            }
            
            updateProgress(100);
            return;
        }
        
        const vocabIndex = reviewQueue[currentCardIndex];
        const item = vocabulary[vocabIndex];
        
        questionEl.textContent = item.term;
        answerEl.textContent = item.description;
        answerEl.classList.add('hidden');
        showAnswerBtn.classList.remove('hidden');
        ratingButtons.classList.add('hidden');
        
        updateProgress((currentCardIndex / reviewQueue.length) * 100);
    }
    
    // Get the next review time
    function getNextReviewTime() {
        let nextTime = Infinity;
        
        vocabulary.forEach((_, index) => {
            const reviewTime = spacedRepetitionData[index].nextReview;
            if (reviewTime > Date.now() && reviewTime < nextTime) {
                nextTime = reviewTime;
            }
        });
        
        return nextTime !== Infinity ? nextTime : null;
    }
    
    // Update progress bar
    function updateProgress(percentage) {
        progressBar.style.width = `${percentage}%`;
    }
    
    // Show answer button handler
    showAnswerBtn.addEventListener('click', function() {
        answerEl.classList.remove('hidden');
        showAnswerBtn.classList.add('hidden');
        ratingButtons.classList.remove('hidden');
    });
    
    // Rating buttons handler
    ratingButtons.addEventListener('click', function(e) {
        if (e.target.classList.contains('rating-btn')) {
            const rating = parseInt(e.target.getAttribute('data-rating'));
            processAnswer(rating);
        }
    });
    
    // Process the user's answer rating
    function processAnswer(rating) {
        const vocabIndex = reviewQueue[currentCardIndex];
        
        // Update spaced repetition data using SM-2 algorithm
        const data = spacedRepetitionData[vocabIndex];
        
        // Convert 1-5 rating to 0-5 for SM-2
        const quality = rating;
        
        // Update repetition data
        if (quality >= 3) {
            // Correct response
            if (data.repetitions === 0) {
                data.interval = 1;
            } else if (data.repetitions === 1) {
                data.interval = 6;
            } else {
                data.interval = Math.round(data.interval * data.easeFactor);
            }
            data.repetitions++;
        } else {
            // Incorrect response
            data.repetitions = 0;
            data.interval = 1;
        }
        
        // Update ease factor
        data.easeFactor = Math.max(1.3, data.easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02)));
        
        // Set next review time (converting days to milliseconds)
        data.nextReview = Date.now() + data.interval * 24 * 60 * 60 * 1000;
        
        // For demo purposes, make reviews happen faster (minutes instead of days)
        // Comment this out for real implementation
        data.nextReview = Date.now() + data.interval * 60 * 1000;
        
        // Move to next card
        currentCardIndex++;
        showNextCard();
        updateStats();
    }
    
    // Update statistics display
    function updateStats() {
        const totalCards = vocabulary.length;
        const dueCards = reviewQueue.length - currentCardIndex;
        const learnedCards = totalCards - dueCards;
        
        statsContainer.innerHTML = `
            <h3>Statistics</h3>
            <p>Total cards: ${totalCards}</p>
            <p>Cards remaining: ${dueCards}</p>
            <p>Cards learned: ${learnedCards}</p>
        `;
    }
});
